<!DOCTYPE html><script type="module">
import App, { Vec3, Quat, Mat4, Transform } from "../../fungi/App.js";
import DragPoints	from "../../fungi.misc/DragPoints.js";


//#####################################################
App
	.init( true )
	.use_events()
	.use_debug()
	.set_camera( 0, 20, 4, 0, 0.9, 0 )
	.then( init );

//#####################################################

let gSkel;
let gRef = new Array();

function on_render( dt, ss ){

}

function init(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	DragPoints.init().set_move_handler( on_pnt_move );


	//for( let p of gSpline.points ){
	//	DragPoints.pnt( p.pos, null, "cyan", 1, size );
	//}
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    setupBodyRig();
    buildDragPoints();

	visualize();
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//App.render_by( 1, on_render );
}


//####################################################################################

function on_pnt_move( idx, pos ){
    let pnt = gRef[ idx ];

    switch( pnt.name ){
        case 'kneeL':
        case 'kneeR':
        case 'elbowL':
        case 'elbowR':
        case 'look':
            gSkel.directions
                .get( pnt.name )
                .setWSPos( pos )
                .resolve();
            updateDragPoints();
            visualize();
            break;

        default: 
            gSkel.setPos( pnt.name, pos );
            gSkel.resolve();
            updateDragPoints();
            visualize();
    }
}

function buildDragPoints(){
    for( let p of gSkel.points.values() ){
        DragPoints.pnt( p.pos, null, "cyan", 1, 0.08 );
        gRef.push( p );
    }
}

function updateDragPoints(){
    for( let i in gRef ){
        DragPoints.move( gRef[ i ].pos, i );
    }
}

function visualize(){
	App.Debug.reset();

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	let g, i, ii;
	for( g of gSkel.groups.values() ){
		switch( g.type ){
			case 'tri' :
				for( i=0; i < g.count; i++ ){
					ii = ( i+1 ) % g.count;
					App.Debug.ln( g.points[ i ].pos, g.points[ ii ].pos, "#00ff00" );
				}
				break;

			default :
				for( i=0; i < g.count-1; i++ ) App.Debug.ln( g.points[ i ].pos, g.points[ i+1 ].pos, "#00ff00" );
				break;
		}
	}

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	let v = new Vec3();
	let w = new Vec3();
	let o;

	for( o of gSkel.directions.values() ){
		App.Debug.ln( o.getAnchorPos( w ), o.getPos( v ), "#ffff00" );
	}
	//o = gSkel.directions.get( 'kneeL' );
	//ln.add( o.getAnchorPos( w ), o.getPos( v ), 0xffff00 );

	//o = gSkel.directions.get( 'look' );
	//ln.add( o.getAnchorPos( w ), o.getPos( v ), 0xffff00 );
}

function setupBodyRig(){
	gSkel = new IKSkeleton();
    gSkel
        .addPoint( 'hip',       [ 0, 1.3, 0 ] )
        .addPoint( 'thighL',    [ 0.2, 1.0, 0.0 ] )
        .addPoint( 'thighR',    [ -0.2, 1.0, 0.0 ] )
        .addPoint( 'footL',     [ 0.2, 0, 0 ] )
        .addPoint( 'footR',     [ -0.2, 0, 0 ] )
        .addPoint( 'shoulderL', [ 0.3, 1.7, 0.0 ] )
        .addPoint( 'shoulderR', [ -0.3, 1.7, 0.0 ] )
        .addPoint( 'neckBase',  [ 0, 1.7, 0.0 ] )
        .addPoint( 'head',      [ 0, 2, 0.0 ] )
        .addPoint( 'handL',     [ 1.0, 1.7, 0.0 ] )
        .addPoint( 'handR',     [ -1.0, 1.7, 0.0 ] )
        .addPoint( 'kneeL',     [ 0, 0, 0 ], Point.DIR )
        .addPoint( 'kneeR',     [ 0, 0, 0 ], Point.DIR )
        .addPoint( 'elbowL',    [ 0, 0, 0 ], Point.DIR )
        .addPoint( 'elbowR',    [ 0, 0, 0 ], Point.DIR )
        .addPoint( 'look',      [ 0, 0, 0 ], Point.DIR )

        .triGroup( 'hip', [ 'hip', 'thighL', 'thighR' ] )
        .triGroup( 'chest', [ 'hip', 'shoulderL', 'shoulderR' ] )
        .rangeLink( 'legL', 'thighL', 'footL' )
        .rangeLink( 'legR', 'thighR', 'footR' )
        .rangeLink( 'armL', 'shoulderL', 'handL' )
        .rangeLink( 'armR', 'shoulderR', 'handR' )
        .midPoint( 'neckBase', 'shoulderL', 'shoulderR' )
        .anchorLink( 'head', 'neckBase', 'head' )

        .pole( 'kneeL', 'legL', [ 0,0,1 ] )
        .pole( 'kneeR', 'legR', [ 0,0,1 ] )
        .pole( 'elbowL', 'armL', [ 0,0,-1 ] )
        .pole( 'elbowR', 'armR', [ 0,0,-1 ] )
        .dir( 'look', 'head', [0,0,1] );
    ;
}


//####################################################################################

// Force a distance between Two Points
class DistanceConstraint{
    constructor( pa, pb ){
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // DATA
        this.a          = pa;                               // First Point
        this.b          = pb;                               // Second Point
        this.lenSqr     = Vec3.len_sqr( pa.pos, pb.pos );    // Distance Squared between Points
        this.len        = Math.sqrt( this.lenSqr );         // Distance between Points

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // OPTIONS
        this.aAnchor    = false;    // First Point is always Pinned
        this.bAnchor    = false;    // Second Point is always Pinned
        this.isRanged   = false;    // Only Resolve if distance is OVER the len

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Reuse, so not reallocating them.
        this.dir        = new Vec3();   
        this.v          = new Vec3();
    }

    ranged(){ this.isRanged = true; return this; }

    resolve(){
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // CHECKS
        
        // If both Points are Pinned, Dont bother
        if( this.a.isPinned && this.b.isPinned ) return false;

        // If distance is less then, then dont bother if its Ranged
        // Apply constraint when its over the max length.
        this.dir.from_sub( this.a.pos, this.b.pos );         // Vector Length
        const curLenSqr = this.dir.len_sqr();                // Len Squared for Quick Checks
        if( Math.abs( curLenSqr - this.lenSqr ) < 0.0001 ||
            ( this.isRanged && curLenSqr <= this.lenSqr ) ) return false;

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        const stiffness = 1.0; // Max Total Ratio
        const curLen    = Math.sqrt( curLenSqr ); // Actual Distance
        const delta     = ( curLen == 0 )? this.len : ( this.len - curLen ) / curLen; // Normalize LenConstraint in relation to current distance of DIR
        
        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Create A & B Ration of how to divide the moment toward eachother.
        // If a Point is pinned, then the other point gets 100% of the movement
        // else the movement is based on the difference of mass each point represents.
        
        let aScl, bScl;
        const aPin = ( this.aAnchor || this.a.isPinned );
        const bPin = ( this.bAnchor || this.b.isPinned );
        
        if( aPin && !bPin ){        aScl = 0;           bScl = stiffness; }
        else if( !aPin && bPin ){   aScl = stiffness;   bScl = 0; }
        else{
            // Compute the Weight between the Two Points using its mass
            aScl = ( this.a.mass / (this.a.mass + this.b.mass) ) * stiffness;
            bScl = stiffness - aScl;    // Since Stiffness is the Max Weight value, Use that to get the inverse of A's Weight Ratio
        }

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Move Points closer or further appart to reach its ideal distance
        if( !aPin ) this.a.pos.add( this.v.from_scale( this.dir, aScl * delta ) );
        if( !bPin ) this.b.pos.sub( this.v.from_scale( this.dir, bScl * delta ) );

        return true;
    }
}


// IK Skeleton is made of Points
class Point{
    static POS = 0;
    static DIR = 1;

    constructor( n, p, t=0, mass=1 ){
        this.name       = n;                // Points Name
        this.pos        = new Vec3( p );    // Point's 3D Position
        this.mass       = mass;             // Used to help Weight Movement in relation to other point weights
        this.isPinned   = false;            // Is this Point not allowed to move?
        this.draggable  = true;             // Is this Point to be user draggable?
        this.type       = t;
    }
}


// IK Skeleton can group Points into specific structures.
class Group{
    constructor( name, type, pntAry ){
        this.name    = name;
        this.type    = type;
        this.points  = pntAry;
        this.count   = pntAry.length;
    }
}


class Pole{
    constructor( name, bendDir, pnt, segA, segB ){
        this.name     = name;
        this.swingDir = Vec3.sub( segB.pos, segA.pos ).norm();
        this.bendDir  = new Vec3( bendDir );
        this.point    = pnt;
        this.aSeg     = segA;
        this.bSeg     = segB;
        this.poleDist = 0.3;
    }

    // Get the Pole Direction based on a World Space Position
    // It the computes the local space direction
    setWSPos( pos ){
        const a     = this.aSeg.pos;                    // Segment Positions
        const b     = this.bSeg.pos;
        const np    = nearestFromPoint( a, b, pos );    // Nearest point from an infinite line from segment points

        const sdir  = Vec3.sub( b, a ).norm();          // Reverse Swing Rotation
        const q     = Quat.unit_vecs( sdir, this.swingDir );

        this.bendDir
            .from_sub( pos, np )     // New Direction
            .norm()                 // Normalize it
            .transform_quat( q );    // Apply Reverse Swing

        return this;
    }

    getPos( out ){ return out.copy( this.point.pos ); }
    getAnchorPos( out ){ return out.from_lerp( this.aSeg.pos, this.bSeg.pos, 0.5 ); }

    // Get Direction of pole after applying swing rotation
    getDir( out ){ 
        let dir = Vec3.sub( this.bSeg.pos, this.aSeg.pos ).norm();
        let q   = Quat.unit_vecs( this.swingDir, dir );        // Swing Rotation
        out.from_quat( q, this.bendDir );
        return out;
    }

    // Update the Point position based on the Pole Direction and attached segment
    resolve(){
        let v = new Vec3();
        this.getDir( this.point.pos )       // Get Curr
            .scale( this.poleDist )
            .add( this.getAnchorPos( v ) );
        return this;
    }
}


class Direction{
    constructor( name, pnt, anchor, dir ){
        this.name       = name;
        this.dir        = new Vec3( dir );
        this.point      = pnt;
        this.anchor     = anchor;
        this.dirDist    = 0.3;
    }

    setWSPos( pos ){
        this.dir
            .from_sub( pos, this.anchor.pos )
            .norm()
        return this;
    }

    getPos( out ){ return out.copy( this.point.pos ); }
    getAnchorPos( out ){ return out.copy( this.anchor.pos ); }

    resolve(){
        this.point.pos
            .from_scale( this.dir, this.dirDist )
            .add( this.anchor.pos );
        return this;
    }
}


class MidPoint{
    constructor( name, pnt, segA, segB ){
        this.name   = name;
        this.point  = pnt;
        this.aSeg   = segA;
        this.bSeg   = segB;
    }

    resolve(){
        let v = Vec3.lerp( this.aSeg.pos, this.bSeg.pos, 0.5 );
        if( Vec3.len_sqr( v, this.point.pos ) <= 0.0001 ) return false;

        this.point.pos.copy( v );
        return true;
    }
}


function nearestFromPoint( a, b, p, out = null ){
    const   dx    = b[0] - a[0],
            dy    = b[1] - a[1],
            dz    = b[2] - a[2],
            t     = ( (p[0]-a[0])*dx + (p[1]-a[1])*dy + (p[2]-a[2])*dz ) / ( dx*dx + dy*dy + dz*dz ),
            ti    = 1 - t;

    out      = out || [ 0,0,0 ];
    out[ 0 ] = a[0] * ti + b[0] * t;
    out[ 1 ] = a[1] * ti + b[1] * t;
    out[ 2 ] = a[2] * ti + b[2] * t;
    return out;
}


class IKSkeleton{
    //#region MAIN
    points      = new Map();    // Collection of Named Points
    groups      = new Map();    // Groupings of Points
    constraints = new Array();  // Collection of Constraints to execute
    iterations  = 5;            // How many times to execute constraints to be fully resolved.
    directions  = new Map();    //
    //#endregion ////////////////////////////////////////////////////

    //#region POINTS
    addPoint( name, pos=null, type=0 ){ 
        this.points.set( name, new Point( name, pos, type ) ); 
        return this;
    }
    
    setPos( name, pos ){ 
        this.points.get( name ).pos.copy( pos ); 
        return this;
    }
    //#endregion ////////////////////////////////////////////////////

    //#region GROUPING
    triGroup( name, pntNames ){
        let i, ii, a, b;
        const pnts = new Array();
        for( i=0; i < pntNames.length; i++ ){
            ii = ( i + 1 ) % pntNames.length;
            a  = this.points.get( pntNames[ i ] );
            b  = this.points.get( pntNames[ ii ] );
            
            pnts.push( a );
            this.constraints.push( new DistanceConstraint( a, b ) );
        }

        this.groups.set( name, new Group( name, "tri", pnts ) );
        return this;
    }

    rangeLink( name, aName, bName ){
        const a  = this.points.get( aName );
        const b  = this.points.get( bName );

        this.constraints.push( new DistanceConstraint( a, b ).ranged() );
        this.groups.set( name, new Group( name, "link", [ a, b ] ) );

        return this;
    }

    anchorLink( name, aName, bName ){
        const a = this.points.get( aName );
        const b = this.points.get( bName );
        const c = new DistanceConstraint( a, b );
        c.aAnchor = true;

        this.constraints.push( c );
        this.groups.set( name, new Group( name, "link", [ a, b ] ) );

        return this;
    }
    
    midPoint( pName, segAName, segBName ){
        const p = this.points.get( pName );
        const a = this.points.get( segAName );
        const b = this.points.get( segBName );
        const c = new MidPoint( pName, p, a, b );
        this.constraints.push( c );
        return this;
    }

    pole( pntName, grpName, bendDir ){
        const pnt = this.points.get( pntName );
        const grp = this.groups.get( grpName );
        const po  = new Pole( pntName, bendDir, pnt, grp.points[ 0 ], grp.points[ 1 ] ).resolve();
        this.directions.set( pntName, po );
        return this;
    }

    dir( pntName, anchorName, dir ){
        const pnt = this.points.get( pntName );
        const anc = this.points.get( anchorName );
        const d   = new Direction( pntName, pnt, anc, dir ).resolve();
        this.directions.set( pntName, d );
        return this;
    }
    //#endregion ////////////////////////////////////////////////////
    
    //#region CONSTRAINTS
    resolve(){
        let i, j, chg;

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        for( i=0; i < this.iterations; i++ ){
            chg = false;
            
            for( j of this.constraints ){
                if( j.resolve() ) chg = true;
            }

            if( !chg ) break;  // Nothing has changed, Exit early.
        }

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        for( i of this.directions.values() ) i.resolve();
    }
    //#endregion ////////////////////////////////////////////////////
}

//#####################################################
</script>
<html><head><style>html,body{ margin:0px; padding:0px; width:100%; height:100%; }</style>
</head><body><canvas id="pg_canvas"></canvas></body></html>