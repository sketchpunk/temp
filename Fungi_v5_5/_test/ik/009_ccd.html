<!DOCTYPE html><script type="module">
import App, { Vec3, Quat, Mat4, Transform } from "../../fungi/App.js";
import ArmFactory	from "../../fungi.armature/ArmFactory.js";;
import DragPoints	from "../../fungi.misc/DragPoints.js";

import Chain			from "../../fungi.ik/Chain.js";
import Target			from "../../fungi.ik/Target.js";
import TriangulationSolver   from "../../fungi.ik/solvers/TriangulationSolver.js";

//#####################################################
App
	.init( true )
	.load_pkg( { name:"fungi.armature", bone_view:true, mat:false } )
	.use_events()
	.use_debug()
	.set_camera( 45, 20, 3, 0, 0.5, 0 )
	.task( init )
	.then();

//#####################################################

let $entity, $tpose, $pose, $chain;

let $end_effector	= new Vec3();
let $pole_effector	= new Vec3();

async function init(){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Systems
	DragPoints.init().set_move_handler( on_pnt_move );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Armature
	let name_ary	= new Array();
	let b_ary		= [ 0.3, 0.3, 0.3 ];
	$entity	= ArmFactory.chain( b_ary, name_ary );
	$tpose	= $entity.arm.new_pose();
	$pose	= $entity.arm.new_pose();

	//$entity.node.set_pos( 0, 0.05, 0 );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	$chain = new Chain().from_armature( $entity.arm, name_ary );

	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	
	//let pos = [ 0.3, 0.7, 0.0 ];
    let pos = [-0.10026335716247559, 0.6032965779304504, 0.71497308015823364 ];
    //let pos = [-0.0038986951112747192, 0.4035147428512573, 0.26106178760528564];

	// IK Targets
	DragPoints.pnt( pos, null, "cyan", 1, 0.06 );
	DragPoints.pnt( [0, 0.0, 0.4 ], null, "yellow", 3, 0.06 );

	DragPoints.get_pos( 0, $end_effector );
    
    apply_ik();

	return true;
}

function on_pnt_move( idx, pos ){
	switch( idx ){
		case 0: $end_effector.copy( pos ); break;
		case 1: $pole_effector.copy( pos ); break;
	}

	apply_ik();
}

function apply_ik(){
	App.Debug.reset();
	let pt = new Transform();
	let ct = new Transform();
	$pose.get_parent_world( $chain.first(), pt, ct, $entity.node.local );

	let pole_dir	= Vec3.sub( $pole_effector, ct.pos );
	let ik			= new Target().from_pos( ct.pos, $end_effector, pole_dir );

	CCDSolver.apply_chain( ik, $chain, $tpose, $pose, pt );
    $pose.apply();
}

class Joint{
    constructor( pw, cl, idx ){
        this.bIndex = idx;
        this.local  = new Transform( cl );
        this.world  = Transform.add( pw, cl );
    }

    update_world( pw ){ this.world.from_add( pw, this.local ); }
    copy_local(){ this.world.copy( this.local ); }
}

class CCDSolver{
    // Create a Copy of the Chain Transform to use for Iterative Processing
    static iter_chain( chain, tpose, p_wt ){
        const cbones = chain.bones;
        const tbones = tpose.bones;
        let i, b, idx, ichain = new Array( chain.count + 1 ); // Extra Transform for End Effector

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Initial Bone is an Extension of a Base Transform
        idx         = cbones[ 0 ].idx;
        b           = tbones[ idx ];
        //ichain[ 0 ] = Transform.add( p_wt, b.local );
        ichain[ 0 ] = new Joint( p_wt, b.local, idx );

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Build up the World Space Transform of the remaining bones.
        for( i=1; i < chain.count; i++ ){
            idx         = cbones[ i ].idx;
            b           = tbones[ idx ];
            //ichain[ i ] = Transform.add( ichain[ i-1], b.local );
            ichain[ i ] = new Joint( ichain[ i-1 ].world, b.local, idx );
        }

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Create the End Effector Transform
        //ichain[ i ] = new Transform(
        //    [ 0, 0, 0, 1 ],         // Quat Identity, No rotation 
        //    [ 0, b.len, 0 ],        // Tail Position of Final Bone
        //    [ 1, 1, 1 ]             // No Scaling
        //).add_rev( ichain[i-1] );   // PrePend Final Bone's WS Transform
        let t = new Transform(
            [ 0, 0, 0, 1 ],         // Quat Identity, No rotation 
            [ 0, b.len, 0 ],        // Tail Position of Final Bone
            [ 1, 1, 1 ]             // No Scaling
        )
        ichain[ i ] = new Joint( ichain[ i-1 ].world, t, -1 );


        //for( i of ichain ) App.Debug.pnt( i.pos, "cyan" );
        return ichain;
    }

    // Update the Iteration Chain, helps know the position of each joint & end effector.
    static update_iter( iter, startIdx ){
        let ii;
        for( let i=startIdx; i < iter.length; i++ ){
            ii = i-1;   // Parent Index
            if( ii >= 0 ) iter[ i ].update_world( iter[ ii ].world );
            else          iter[ i ].copy_local();
        }
    }

    static apply_chain( ik, chain, tpose, pose, p_wt ){
        // Create a copy of the chain's ws tranforms for iterative processing
        const iter      = this.iter_chain( chain, tpose, p_wt );
        const tries     = 20;                   // Max Iterations to reach end effector
        const rng       = 0.01**2;
        let   step     = 0;                    // Current Interation Step.
        let   endIdx    = iter.length - 2;      // Final Joint Doesn't Count, Its the End Effector
        let   eff       = iter[ endIdx + 1 ];   // Reference to the End Effector Joint
        let   i;
        let   b;
        let   diff;
        let   effDir    = new Vec3();
        let   tarDir    = new Vec3();

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        for( step; step < tries; step++ ){
            for( i=endIdx; i >= 0; i-- ){
                b    = iter[ i ];
                diff = Vec3.len_sqr( eff.world.pos, ik.end_pos );

                //console.log( "TEST", step, i, "is", diff, "<=", rng, ( diff <= rng ) );
                if( diff <= rng ){ step = tries+1; break; } // Break out of Both Loops

                //--------------------------------------
                effDir.from_sub( eff.world.pos, b.world.pos ).norm();
                tarDir.from_sub( ik.end_pos, b.world.pos ).norm();

                b.local.rot.mul_unit_vecs( effDir, tarDir );

                //--------------------------------------
                this.update_iter( iter, i );
            }
        }

        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // Save Results to Pose
        for( i=0; i <= endIdx; i++ ){
            pose.set_local_rot( iter[ i ].bIndex, iter[ i ].local.rot );
        }
    }

}


/*
public class CCDIKJoint : MonoBehaviour {
  public Vector3 axis = Vector3.right;
  public float maxAngle = 180;
  Vector3 perpendicular; void Start() { perpendicular = axis.Perpendicular(); }

  public void Evaluate(Transform ToolTip, Transform Target, bool rotateToDirection = false) {
    //Rotate the assembly so the tooltip better matches the target position/direction
    transform.rotation = (rotateToDirection ? Quaternion.FromToRotation(ToolTip.up, Target.forward) : Quaternion.FromToRotation(ToolTip.position - transform.position, Target.position - transform.position)) * transform.rotation;

    //Enforce only rotating with the hinge
    transform.rotation = Quaternion.FromToRotation(transform.rotation * axis, transform.parent.rotation * axis) * transform.rotation;

    //Enforce Joint Limits
    transform.rotation = Quaternion.FromToRotation(transform.rotation * perpendicular, (transform.rotation * perpendicular).ConstrainToNormal(transform.parent.rotation * perpendicular, maxAngle)) * transform.rotation;
  }
}
*/


// The Quaternion CCDIK Step
  // An example of a cleaner implementation can be seen in the Unity code:
  // https://github.com/zalo/MathUtilities/blob/master/Assets/IK/CCDIK/CCDIKJoint.cs
  // https://codepen.io/zalo/pen/MLBKBv?editors=0010
 let solveIK = function (targetPosition) {
    var tooltipPosition = new THREE.Vector3();
    var toolRotation = new THREE.Quaternion();
    var fromToQuat = new THREE.Quaternion();
    for (var i = this.IKJoints.length - 1; i >= 0; i--) {
      this.IKJoints[i].updateMatrixWorld();
      this.endEffector.getWorldPosition(tooltipPosition);

      if (this.matchDirection) {
        tooltipPosition.add(new THREE.Vector3(3.25, 0, 0));
      }

      // (Ideally this could be done entirely in worldspace (instead of local space
      // (which require all of these terrible hacks that you see)))

      // Decide whether to point _toward_ the target, or along the target's direction
      if (this.matchDirection && (i > this.IKJoints.length - 3)) {
        // Rotate to align with a direction
        var toolDirection = new THREE.Vector3(1.0, 0, 0);
        this.endEffector.getWorldQuaternion(toolRotation);
        var invToolRotation = toolRotation.clone().inverse();
        var targetDirection = toolDirection.clone().applyQuaternion(invToolRotation);
        if (i == this.IKJoints.length - 2) {
          toolDirection.applyQuaternion(this.IKJoints[this.IKJoints.length - 1].quaternion);
          targetDirection.applyQuaternion(this.IKJoints[this.IKJoints.length - 1].quaternion);
        }
        fromToQuat.setFromUnitVectors(toolDirection, targetDirection);
        this.IKJoints[i].quaternion.multiply(fromToQuat);
      } else if (this.ccd) {
        // Rotate towards the Target
        var toolDirection = this.IKJoints[i].worldToLocal(tooltipPosition.clone()).normalize();
        var targetDirection = this.IKJoints[i].worldToLocal(targetPosition.clone()).normalize();
        fromToQuat.setFromUnitVectors(toolDirection, targetDirection);
        this.IKJoints[i].quaternion.multiply(fromToQuat);
      }

      // Find the rotation from here to the parent, and rotate the axis by it...
      // This ensures that were always rotating with the hinge
      // (this can also be "done" by projecting the directions in the block above
      // to the plane of the axis of rotation, but that allows for the joint's hinge 
      // angle to drift due to floating point inaccuracy)
      if (this.hinge) {
        var invRot = this.IKJoints[i].quaternion.clone().inverse();
        var parentAxis = this.IKJoints[i].axis.clone().applyQuaternion(invRot);
        fromToQuat.setFromUnitVectors(this.IKJoints[i].axis, parentAxis);
        this.IKJoints[i].quaternion.multiply(fromToQuat);
      }

      // Clamp to Joint Limits - Relies on sensical computation of these values... only works for x-axis here ¯\_(ツ)_/¯
      // Seems like rotations range from -pi, pi... not the worst... but bad for clamps through there
      if (this.limits) {
        var clampedRot = this.IKJoints[i].rotation.toVector3().clampScalar(this.IKJoints[i].minLimit, this.IKJoints[i].maxLimit);
        this.IKJoints[i].rotation.setFromVector3(clampedRot);
      }

      this.IKJoints[i].updateMatrixWorld();
    }
  }


  //https://codepen.io/zalo/pen/MLBKBv?editors=0010
  //Beautiful CCDIK
  function solveIK2(targetPosition) {
      var tooltipPosition = new THREE.Vector3();
      for (var i = IKJoints.length - 1; i >= 0; i--) {
        IKJoints[i].updateMatrixWorld();
        endEffector.getWorldPosition(tooltipPosition);

        //Rotate towards the Target
        //(Ideally this could be done entirely in worldspace (instead of local space))
        var toolDirection = IKJoints[i].worldToLocal(tooltipPosition.clone()).normalize();
        var targetDirection = IKJoints[i].worldToLocal(targetPosition.clone()).normalize();
        var fromToQuat = new THREE.Quaternion(0, 0, 0, 1).setFromUnitVectors(toolDirection, targetDirection);
        IKJoints[i].quaternion.multiply(fromToQuat);

        //Find the rotation from here to the parent, and rotate the axis by it...
        //This ensures that you're always rotating with the hinge
        var invRot = IKJoints[i].quaternion.clone().inverse();
        var parentAxis = IKJoints[i].axis.clone().applyQuaternion(invRot);
        fromToQuat.setFromUnitVectors(IKJoints[i].axis, parentAxis);
        IKJoints[i].quaternion.multiply(fromToQuat);

        //Clamp to Joint Limits - Devious and relies on sensical computation of these values...
        //Seems like rotations range from -pi, pi... not the worst... but bad for clamps through there
        var clampedRot = IKJoints[i].rotation.toVector3().clampScalar(IKJoints[i].minLimit, IKJoints[i].maxLimit);
        IKJoints[i].rotation.setFromVector3(clampedRot);

        IKJoints[i].updateMatrixWorld();
      }
    }


//#####################################################
</script>
<html><head><style>html,body{ margin:0px; padding:0px; width:100%; height:100%; }</style>
</head><body><canvas id="pg_canvas"></canvas></body></html>